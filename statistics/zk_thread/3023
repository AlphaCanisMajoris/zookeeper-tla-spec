STATE_1 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ electing = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ recorder = [ step |-> 0,
  nTimeout |-> 0,
  nTransaction |-> 0,
  nPartition |-> 0,
  maxEpoch |-> 0,
  nCrash |-> 0,
  pc |-> <<"Init">>,
  nClientRequest |-> 0,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 0 @@ s1 :> 0 @@ s0 :> 0)
/\ connecting = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ proposalMsgsLog = {}
/\ hzxid = (s2 :> <<0, 0>> @@ s1 :> <<0, 0>> @@ s0 :> <<0, 0>>)
/\ lastCommitted = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 0 @@ s1 :> 0 @@ s0 :> 0)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 0 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<>>
/\ epochLeader = <<{}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_2 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> @@
        s0 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ recorder = [ step |-> 1,
  nPartition |-> 0,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 0,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"SetInitState", s2, {s1, s0}>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 1 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_3 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ recorder = [ step |-> 2,
  nPartition |-> 1,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s2, s0}>>},
  nTimeout |-> 1,
  nCrash |-> 0,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"PartitionStart", s2, s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 1 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_4 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 3,
  nPartition |-> 1,
  nConsequentFailure |-> 2,
  noExecute |-> {<<"PartitionStart", {s2, s0}>>, <<"NodeCrash", s2>>},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"NodeCrash", s2>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 1 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> OFFLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_5 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 4,
  nPartition |-> 1,
  nConsequentFailure |-> 2,
  noExecute |-> {<<"PartitionStart", {s2, s0}>>, <<"NodeCrash", s2>>},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 1,
  pc |-> <<"NodeStart", s2>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 1 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 1 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> FALSE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_6 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 5,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |->
      << "ElectionAndDiscovery",
         s2,
         {s1},
         1,
         [index |-> 2, zxid |-> <<1, 2>>],
         2 >>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_7 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> DIFF, mzxid |-> <<1, 2>>, mindex |-> 1],
               [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<2, 0>>] >> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 6,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"LeaderSyncFollower", s2, s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_8 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> DIFF, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<1, 2>>, mdata |-> 102],
               [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<2, 0>>] >> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 7,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerProcessSyncMessage", s1, s2, <<1, 2>>, DIFF>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_9 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> DIFF, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> COMMIT, mzxid |-> <<1, 2>>],
               [mtype |-> NEWLEADER, mzxid |-> <<2, 0>>] >> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 8,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerProcessPROPOSALInSync", s1, s2, <<1, 2>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>>,
        committed |-> <<>> ] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_10 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> DIFF, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<2, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 9,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerProcessCOMMITInSync", s1, s2, <<1, 2>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 1 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :>
      [ notCommitted |->
            <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>>,
        committed |-> <<<<1, 2>>>> ] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_11 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<2, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 10,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerProcessNEWLEADER_0", s1, s2, <<2, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> INITIAL @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_12 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<2, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 11,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerReplyACKLD", s1, s2, <<2, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> INITIAL @@ s0 :> SHUTDOWN)
/\ committedLog = <<[zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1, s0}, epoch |-> 1]>>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_13 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<2, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> UPTODATE, mzxid |-> <<2, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 12,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"LeaderProcessACK", s2, s1, <<2, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<<<1, 2>>>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_14 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<2, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<2, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 13,
  nPartition |-> 1,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 2,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"FollowerProcessUPTODATE", s1, s2, <<2, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> TRUE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<<<1, 2>>>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_15 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s1} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<2, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 14,
  nTimeout |-> 2,
  nTransaction |-> 2,
  nPartition |-> 1,
  maxEpoch |-> 2,
  nCrash |-> 1,
  pc |-> <<"LeaderProcessACK", s2, s1, <<2, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<2, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<<<1, 2>>>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_16 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 15,
  nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s2, s1}>>},
  nTimeout |-> 3,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"PartitionStart", s2, s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> TRUE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_17 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 16,
  nPartition |-> 2,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"PartitionStart", {s2, s1}>>},
  nTimeout |-> 3,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"PartitionRecover", s2, s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_18 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 17,
  nPartition |-> 3,
  nConsequentFailure |-> 2,
  noExecute |->
      { <<"PartitionStart", {s2, s1}>>,
        <<"PartitionStart", {s1, s0}>>,
        <<"PartitionRecover", {s1, s0}>> },
  nTimeout |-> 3,
  nCrash |-> 1,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"PartitionStart", s1, s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_19 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :> <<>> )
/\ recorder = [ step |-> 18,
  nPartition |-> 3,
  nConsequentFailure |-> 3,
  noExecute |->
      { <<"PartitionStart", {s2, s1}>>,
        <<"PartitionStart", {s1, s0}>>,
        <<"NodeCrash", s1>>,
        <<"NodeStart", s1>>,
        <<"PartitionRecover", {s1, s0}>> },
  nTimeout |-> 3,
  nCrash |-> 2,
  nTransaction |-> 2,
  maxEpoch |-> 2,
  pc |-> <<"NodeCrash", s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 2 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 2 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> OFFLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s1, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {}, {}, {}, {}, {}, {}, {}, {}>>


STATE_20 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> ELECTION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 19,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {<<"NodeCrash", s1>>},
  nTimeout |-> 3,
  nCrash |-> 2,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |->
      << "ElectionAndDiscovery",
         s2,
         {s0},
         2,
         [index |-> 2, zxid |-> <<1, 2>>],
         3 >>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<3, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> OFFLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> LOOKING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_21 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 20,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"NodeCrash", s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> OFFLINE @@ s0 :> OFFLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_22 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 21,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"NodeStart", s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> OFFLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_23 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 22,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"NodeStart", s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) @@
  s1 :> (s2 :> TRUE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_24 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 23,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"PartitionRecover", s2, s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_25 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 24,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"FollowerSyncProcessorLogRequest", s1, s1, <<1, 2>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> TRUE) @@
  s0 :> (s2 :> FALSE @@ s1 :> TRUE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_26 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> ELECTION @@ s1 :> ELECTION @@ s0 :> ELECTION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 25,
  nPartition |-> 3,
  nConsequentFailure |-> 1,
  noExecute |-> {<<"NodeCrash", s1>>, <<"NodeCrash", s0>>},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 3,
  pc |-> <<"PartitionRecover", s1, s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 3)
/\ connecting = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<1, 2>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 3 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 3 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = NullPoint
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LOOKING @@ s1 :> LOOKING @@ s0 :> LOOKING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}, {}>>


STATE_27 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 26,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |->
      << "ElectionAndDiscovery",
         s2,
         {s1, s0},
         3,
         [index |-> 2, zxid |-> <<1, 2>>],
         4 >>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_28 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 1, zxid |-> <<1, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<>> @@
        s0 :>
            << [ mtype |-> SNAP,
                 mzxid |-> <<1, 2>>,
                 msnapshot |->
                     << [ zxid |-> <<1, 1>>,
                          value |-> 101,
                          ackSid |-> {s2},
                          epoch |-> 1 ],
                        [ zxid |-> <<1, 2>>,
                          value |-> 102,
                          ackSid |-> {s2},
                          epoch |-> 1 ] >> ],
               [mtype |-> NEWLEADER, mzxid |-> <<4, 0>>] >> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> )
/\ recorder = [ step |-> 27,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"LeaderSyncFollower", s2, s0>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_29 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> SNAP, nlRcv |-> FALSE] )
/\ forwarding = (s2 :> {s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<>> @@
        s0 :> <<[mtype |-> NEWLEADER, mzxid |-> <<4, 0>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 28,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessSyncMessage", s0, s2, <<1, 2>>, SNAP>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 1)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [zxid |-> <<0, 0>>, index |-> 0] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> SHUTDOWN)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_30 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<>> @@
        s0 :> <<[mtype |-> NEWLEADER, mzxid |-> <<4, 0>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 29,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessNEWLEADER_0", s0, s2, <<4, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> INITIAL)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_31 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> SYNCHRONIZATION @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 30,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"FollowerReplyACKLD", s0, s2, <<4, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = (s2 :> {[sid |-> s2, connected |-> TRUE]} @@ s1 :> {} @@ s0 :> {})
/\ servingState = (s2 :> SHUTDOWN @@ s1 :> SHUTDOWN @@ s0 :> INITIAL)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2, s1}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_32 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<1, 1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<>> @@
        s0 :> <<[mtype |-> UPTODATE, mzxid |-> <<4, 0>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 31,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"LeaderProcessACK", s2, s0, <<4, 0>>>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> SHUTDOWN @@ s0 :> INITIAL)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_33 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 1, zxid |-> <<1, 1>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [ mtype |-> SNAP,
                 mzxid |-> <<4, 0>>,
                 msnapshot |->
                     << [ zxid |-> <<1, 1>>,
                          value |-> 101,
                          ackSid |-> {s2},
                          epoch |-> 1 ],
                        [ zxid |-> <<1, 2>>,
                          value |-> 102,
                          ackSid |-> {s2, s0},
                          epoch |-> 1 ] >> ],
               [mtype |-> NEWLEADER, mzxid |-> <<4, 0>>] >> @@
        s0 :> <<[mtype |-> UPTODATE, mzxid |-> <<4, 0>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [ zxid |-> <<1, 1>>,
           value |-> 101,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {}, epoch |-> 2] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 32,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"LeaderSyncFollower", s2, s1>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> SHUTDOWN @@ s0 :> INITIAL)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_34 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> SNAP, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> SYNCHRONIZATION)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<4, 0>>]>> @@
        s0 :> <<[mtype |-> UPTODATE, mzxid |-> <<4, 0>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 33,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 2,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessSyncMessage", s1, s2, <<4, 0>>, SNAP>>,
  nClientRequest |-> 2 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> SHUTDOWN @@ s0 :> INITIAL)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_35 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> SNAP, nlRcv |-> FALSE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<4, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 34,
  nTimeout |-> 4,
  nTransaction |-> 2,
  nPartition |-> 3,
  maxEpoch |-> 4,
  nCrash |-> 3,
  pc |-> <<"FollowerProcessUPTODATE", s0, s2, <<4, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 2 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [zxid |-> <<0, 0>>, index |-> 0] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> SHUTDOWN @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_36 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> NEWLEADER, mzxid |-> <<4, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 35,
  nTimeout |-> 4,
  nTransaction |-> 2,
  nPartition |-> 3,
  maxEpoch |-> 4,
  nCrash |-> 3,
  pc |-> <<"FollowerProcessNEWLEADER_0", s1, s2, <<4, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_37 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 36,
  nTimeout |-> 4,
  nTransaction |-> 2,
  nPartition |-> 3,
  maxEpoch |-> 4,
  nCrash |-> 3,
  pc |-> <<"FollowerReplyACKLD", s1, s2, <<4, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_38 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 37,
  nTimeout |-> 4,
  nTransaction |-> 2,
  nPartition |-> 3,
  maxEpoch |-> 4,
  nCrash |-> 3,
  pc |-> <<"LeaderProcessACK", s2, s0, <<4, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :> {[sid |-> s2, connected |-> TRUE], [sid |-> s0, connected |-> TRUE]} @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_39 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> UPTODATE, mzxid |-> <<4, 0>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 38,
  nTimeout |-> 4,
  nTransaction |-> 2,
  nPartition |-> 3,
  maxEpoch |-> 4,
  nCrash |-> 3,
  pc |-> <<"LeaderProcessACK", s2, s1, <<4, 0>>>>,
  nClientRequest |-> 2,
  nConsequentFailure |-> 0,
  noExecute |-> {} ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102] }
/\ hzxid = (s2 :> <<4, 0>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_40 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2}, epoch |-> 4] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> SYNCHRONIZATION @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> UPTODATE, mzxid |-> <<4, 0>>],
               [mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2] >> @@
        s0 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 39,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"LeaderProcessRequest", s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> INITIAL @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_41 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2}, epoch |-> 4] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> @@
        s0 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> ) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 40,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessUPTODATE", s1, s2, <<4, 0>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_42 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2}, epoch |-> 4] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<>> @@
  s0 :> <<[zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4]>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> @@
        s0 :> <<>> ) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 0>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 41,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessPROPOSAL", s0, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_43 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2}, epoch |-> 4] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<>> @@
  s0 :> <<[zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4]>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 42,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"LeaderProcessACK", s2, s1, <<4, 0>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 0, zxid |-> <<0, 0>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_44 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2}, epoch |-> 4] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 1>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 43,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerSyncProcessorLogRequest", s0, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_45 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2],
               [mtype |-> COMMIT, mzxid |-> <<4, 1>>] >> @@
        s0 :> <<[mtype |-> COMMIT, mzxid |-> <<4, 1>>]>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 44,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"LeaderProcessACK", s2, s0, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_46 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2],
               [mtype |-> COMMIT, mzxid |-> <<4, 1>>] >> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 45,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessCOMMIT", s0, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<<<4, 1>>>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_47 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :>
            << [mtype |-> PROPOSAL, mzxid |-> <<4, 1>>, mdata |-> 2],
               [mtype |-> COMMIT, mzxid |-> <<4, 1>>] >> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 46,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerCommitProcessorCommit", s0, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_48 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = ( s2 :> <<>> @@
  s1 :> <<[zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4]>> @@
  s0 :> <<>> )
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> COMMIT, mzxid |-> <<4, 1>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 47,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessPROPOSAL", s1, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 0, zxid |-> <<0, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_49 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> COMMIT, mzxid |-> <<4, 1>>]>> @@
        s0 :> <<>> ) @@
  s1 :>
      ( s2 :> <<[mtype |-> ACK, mzxid |-> <<4, 1>>]>> @@
        s1 :> <<>> @@
        s0 :> <<>> ) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 48,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerSyncProcessorLogRequest", s1, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_50 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s1, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :>
      ( s2 :> <<>> @@
        s1 :> <<[mtype |-> COMMIT, mzxid |-> <<4, 1>>]>> @@
        s0 :> <<>> ) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 49,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"LeaderProcessACK", s2, s1, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s1, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_51 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s1, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 50,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerProcessCOMMIT", s1, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<<<4, 1>>>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s1, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


STATE_52 == 
/\ connectInfo = ( s2 :> [sid |-> NullPoint, syncMode |-> NONE, nlRcv |-> FALSE] @@
  s1 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] @@
  s0 :> [sid |-> s2, syncMode |-> NONE, nlRcv |-> TRUE] )
/\ forwarding = (s2 :> {s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ history = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s1, s0},
           epoch |-> 1 ],
         [ zxid |-> <<4, 1>>,
           value |-> 2,
           ackSid |-> {s2, s1, s0},
           epoch |-> 4 ] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s0}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {}, epoch |-> 4] >> )
/\ electing = ( s2 :>
      { [sid |-> s2, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s1, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE],
        [sid |-> s0, peerLastZxid |-> <<-1, -1>>, inQuorum |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ zabState = (s2 :> BROADCAST @@ s1 :> BROADCAST @@ s0 :> BROADCAST)
/\ queuedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ aaInv = [ leadership |-> TRUE,
  integrity |-> TRUE,
  agreement |-> TRUE,
  totalOrder |-> TRUE,
  localPrimaryOrder |-> TRUE,
  globalPrimaryOrder |-> TRUE,
  primaryIntegrity |-> TRUE,
  commitCompleteness |-> TRUE,
  commitConsistency |-> TRUE,
  historyConsistency |-> TRUE ]
/\ lastProcessed = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ rcvBuffer = ( s2 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s1 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) @@
  s0 :> (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>) )
/\ initialHistory = ( s2 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> @@
  s1 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [ zxid |-> <<1, 2>>,
           value |-> 102,
           ackSid |-> {s2, s0},
           epoch |-> 1 ] >> @@
  s0 :>
      << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
         [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2}, epoch |-> 1] >> )
/\ recorder = [ step |-> 51,
  nPartition |-> 3,
  nConsequentFailure |-> 0,
  noExecute |-> {},
  nTimeout |-> 4,
  nCrash |-> 3,
  nTransaction |-> 3,
  maxEpoch |-> 4,
  pc |-> <<"FollowerCommitProcessorCommit", s1, s2, <<4, 1>>>>,
  nClientRequest |-> 3 ]
/\ acceptedEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ connecting = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ proposalMsgsLog = { [zxid |-> <<1, 1>>, epoch |-> 1, source |-> s2, data |-> 101],
  [zxid |-> <<1, 2>>, epoch |-> 1, source |-> s2, data |-> 102],
  [zxid |-> <<1, 2>>, epoch |-> 2, source |-> s2, data |-> 102],
  [zxid |-> <<4, 1>>, epoch |-> 4, source |-> s2, data |-> 2] }
/\ hzxid = (s2 :> <<4, 1>> @@ s1 :> <<1, 1>> @@ s0 :> <<1, 1>>)
/\ lastCommitted = ( s2 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s1 :> [index |-> 3, zxid |-> <<4, 1>>] @@
  s0 :> [index |-> 3, zxid |-> <<4, 1>>] )
/\ daInv = [ messageLegal |-> TRUE,
  stateConsistent |-> FALSE,
  proposalConsistent |-> TRUE,
  commitConsistent |-> TRUE,
  ackConsistent |-> TRUE ]
/\ currentEpoch = (s2 :> 4 @@ s1 :> 4 @@ s0 :> 4)
/\ learners = (s2 :> {s2, s1, s0} @@ s1 :> {} @@ s0 :> {})
/\ tempMaxEpoch = (s2 :> 4 @@ s1 :> 0 @@ s0 :> 0)
/\ leaderOracle = s2
/\ lastSnapshot = ( s2 :> [index |-> 2, zxid |-> <<1, 2>>] @@
  s1 :> [index |-> 2, zxid |-> <<4, 0>>] @@
  s0 :> [index |-> 2, zxid |-> <<1, 2>>] )
/\ committedRequests = (s2 :> <<>> @@ s1 :> <<>> @@ s0 :> <<>>)
/\ status = (s2 :> ONLINE @@ s1 :> ONLINE @@ s0 :> ONLINE)
/\ state = (s2 :> LEADING @@ s1 :> FOLLOWING @@ s0 :> FOLLOWING)
/\ partition = ( s2 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s1 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) @@
  s0 :> (s2 :> FALSE @@ s1 :> FALSE @@ s0 :> FALSE) )
/\ packetsSync = ( s2 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s1 :> [notCommitted |-> <<>>, committed |-> <<>>] @@
  s0 :> [notCommitted |-> <<>>, committed |-> <<>>] )
/\ ackldRecv = ( s2 :>
      { [sid |-> s2, connected |-> TRUE],
        [sid |-> s1, connected |-> TRUE],
        [sid |-> s0, connected |-> TRUE] } @@
  s1 :> {} @@
  s0 :> {} )
/\ servingState = (s2 :> RUNNING @@ s1 :> RUNNING @@ s0 :> RUNNING)
/\ committedLog = << [zxid |-> <<1, 1>>, value |-> 101, ackSid |-> {s2}, epoch |-> 1],
   [zxid |-> <<1, 2>>, value |-> 102, ackSid |-> {s2, s1, s0}, epoch |-> 1],
   [zxid |-> <<4, 1>>, value |-> 2, ackSid |-> {s2, s1, s0}, epoch |-> 4] >>
/\ epochLeader = <<{s2}, {s2}, {s2}, {s2}, {}, {}, {}, {}, {}, {}>>


=================================================
